% is =:= =!=
% > < =< >=
% + / - * ^ div mod
% ** //

% = не е аритметика, то прави двустранен pattern matching
% is е аритметика, първо се прави аритметично оценяване на израза отдясно
% и ще се опита да го унифицира с лявата част, затова отляво трябва винаги
% да седи или пресметнат вече аритметичен израз, или променлива
% 5+1 is 6 -> false
% 6 is 5+1 -> true
% x is [] -> false
% трябва да се сведе до число
% т.е. изчислява се това вдясно и ако това вляво няма стойност, се присвоява дясното
% като стойност на променливата вляво, ако има стоност, се сравняват 2те

% =:= извършва аритметично пресмятане отляво и отдясно, не извършва присвояване
% проверява дали са един и същ терм, знае само числа, не може да сравнява др.неща
% отрицание на =:= е =!=
% 6+1 =:= 4+3

% div, // целочислено деление
% mod процентно деление/остатък

% зад.1
% не можем да разменим is и len, защото първо трябва да пресметнем стойността на У
% и след това да се извърши аритметика, всички променливи трябва да са истанцирани
% които се намират от дясната страна на is
len([],0).
len([_|Tail],X):-len(Tail,Y), X is Y+1.

sum([],0).
sum([H|Tail],X):-sum(Tail,Y),X is Y+H.

% nth element
% това решение решава абсолютно всички задачи-разпознава и генерира
nthElement(X,0,[X|_]).
% не можем да напишем N-1 като аргумент на nthElement, защото е аритметика
nthElement(X,N,[_|Tail]):-nthElement(X,M,Tail), N is M+1.

% мазало
nthElement2(X,N,[X|_]):- N =:= 0.
nthElement2(X,N,[_|Tail]):-write(N),nl,nthElement2(X,N-1,Tail).

nthElement3(X,0,[X|_]).
nthElement3(X,N,[_|Tail]):- M is N-1, nthElement3(X,M,Tail).
% nthElement3(X,N,[1,2,3,4,6]) - първият път казва 0, после умира,
% защото не знаем колко е N, т.е. не можем да извадим 1
% затова го мислим индуктивно, X e на н-та позиция в списъка, следователно
% е на н+1 позиция в по-големия списък

% зад. 2
% генериране на редици чрез преудовлетворяване
natural(0).
natural(X):-natural(Y),X is Y+1.
% natural(5) връща истина, но при преудовлетворяване, ще продължи да търси 
% безкрайно за друга 5ца, т.е. не го ползваме за разпознавател 

even(X):- natural(X), X mod 2 =:= 0.

% 0, 1, 2, 3, 4
% 0, 2, 4
% 0, 1, -1, 2, -2
% 0, 1, 1, 2, 3, 5, 8, 13

% използваме кодиране, всяко ест число, ако е четно -> отрицателно, нечетно -> положително
int(X):-natural(Y),decodeInt(Y,X).
decodeInt(Y,X):-Y mod 2 =:= 0, X is -Y // 2.
decodeInt(Y,X):-Y mod 2 =:= 1, X is (Y+1) // 2.

% преудовлетворяване- връща се по обратен ред на извикванията, по същество дфс
% ще влезе в sign(x,x) и после в sign(x,y), после ще се върне на natural
% backtracking, караме го да намери всички възможни пътища
int2(X):-natural(Y), sign(Y,X).
sign(X,X).
sign(X,Y):-X>0, Y is -X.

int3(0).
int3(X):-natural(Y), Y>0, member(Z,[1,-1]),X is Y*Z.

% не работи, след 20 зацикля, ако разменим условията, няма да е дефиниран Х
% natural20(X):-natural(X),X<21.

between(A,B,A):-A =< B.
between(A,B,X):-A < B, A1 is A+1, between(A1,B,X).

natural20(X):- between(0,20,X).

% за да форсираме да се покаже целият резултат, натискаме w
range(A,B,[]):- A>B.
range(A,B,[A|Tail]):- A=<B, A1 is A+1, range(A1,B,Tail).

% всички двойки естествени числа
% това би въртяло безкраен цикъл по У, защото е първото, което ще се преъдовлетвори,
% т.е. няма да работи добре
% pairNatural():-natural(X),natural(Y).
pairNatural(X,Y):- natural(Z),between(0,Z,X), Y is Z-X.

% зад. 3
% списък от елементи със сума S, т.е. сума на н-орка, сума на N елемента от L трябва да е S
% решаваме у-то x1+x2+...+xn=s
gen(0,0,[]).
gen(N,S,[H|Tail]):-N>0, between(0,S,H), S1 is S-H, N1 is N-1, gen(N1,S1,Tail).

% генериране на всички н-орки
% трябва да позволим на S да се мени, т.е. взимаме S да е естествено число и генерираме всички 
% списъци с н елемента, които имат сума S
allNorks(N,L):-natural(S),gen(N,S,L).
% ако и N може да се мени, т.е. ако вземем всички наредени двойки от ест. числа
% за N и S, и след това пускаме генератора, има 2 степени на свобода
allFiniteNaturalNumberSequences(L):-pairNatural(N,S), gen(N,S,L).

% зад. 4
% фибоначи
% f(n,first,second){
%   if(n==0) return first;
%   return f(n-1,second, first+second);
% }

% това е за да го пуснем в началото
% после директно влиза във втория ред и при преудовлетворяване продължава нататък
fib(X):-fib(X,_).
fib(0,1).
fib(Y,Z):-fib(X,Y), Z is X+Y.

% fibCheck(X)
% не можем да използваме fib, защото ще зацикли ако не е Х в редицата
% ако е, ще каже да и после ще зацикли
% третият аргумент е лимита
fibCheck(X):-fib2(0,1,X).
fib2(X,_,X).
fib2(X,Y,L):-X<L, Z is X+Y, fib2(Y,Z,L).

% зад. 5 (задача от контролно)
% a0 = a1 = a2 = 1
% a(n+3) = an + a(n+1) {+ 0*a(n+2)}
% а0 а1 а2
a(1,1,1).
% an a(n+1) (an+3)
a(Y,Z,T):-a(X,Y,Z), T is X+Y.
a(X):-a(X,_,_).
